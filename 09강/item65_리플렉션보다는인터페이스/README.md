## Item 65 : 리플렉션보다는 인터페이스를 사용하라
### Conclusion
리플렉션은 제한적으로만 사용해야하고, 이를 위해서 인터페이스를 사용하라.

### In case
자바가 제공하는 리플렉션은 임의의 클래스에 접근할 수 있는 도구이다.  

패키지와 클래스 이름을 안다면 런타임에 동적으로 클래스를 불러올수 있고,   
동적으로 인스턴스를 생성하고 메서드를 호출, 멤버변수를 변경할 수 있도록 한다.  

코드를 작성하는 시점에는 어떤 클래스일지 모르지만 런타임 시점에 불러와 사용해야하는 경우 사용됨.
- 실제 타입은 모르지만 어쨌든 사용되어야 한다는 점에서 인터페이스의 설명과 비슷하게 들림

딱봐도 매우 강력해 보이는 기능이지만..

장점
- 런타임 시점에 인스턴스를 생성하도록 유도할 수 있다.
- 접근 제어자를 무시할수 있다.

단점
- 컴파일 타임에 이루어지는 타입검사를 할수 없다.
- 위와 마찬가지로, 체크 예외도 우회 한다.
- 코드가 지저분해진다.
- (일반적으로) 성능이 떨어진다 알려짐. 
- 접근 제어자를 무시할수 있다.(캡슐화)

여기서, 제한된 형태로만 사용하기 위해 인터페이스로 단점을 상쇄하는 코드를 작성하기를 권장한다.

첨부된 소스파일 참고



## in my opinion
리플렉션의 기능을 인터페이스로 대신할수 있다 라는 내용의 챕터가 아니라,  
리플렉션은 위험하니 그나마 안전하게 인터페이스로 타이핑해서 사용하라 라는 내용이었음.

리플렉션으로 작성된 코드는 대부분의 인자가 Object와 String 타입이라 실수를 할 가능성이 매우 높음.  
코드를 봐도 직관적이지 못하고, 비즈니스에 집중하기 보다는 생성과 실행에 집중하여 추상화의 필요성이 생기며,  
용도가 용도이다 보니 캡슐화를 저해하는 결과를 가진다.

그럼에도 강력한 기능 때문에 사용해야하는 경우가 많은데, 
책에서 설명한대로 현재는 많이 걷어내긴 했지만 대표적으로 Spring AOP(dynamic proxy)에서도 사용하고 있다.  
(내가 쓰지 않는다고 사용하지 않는게 아님)  
이때문에 결과적으로는 boot 이전의 Spring에서는 빈에 인터페이스 사용을 강제하였음.
지금은 cglib proxy를 이용하기 때문에 final class가 아닌 클래스에 한해서 proxy 사용이 가능해졌음.

다만 책에서 권장하는 대로 인터페이스를 이용한 코드를 작성할시 강력한 기능에 비해 제한된 코드를 작성하게 되는데,  
리플렉션을 이용하는 이유는 코드를 작성하는 시점에 사용되는 클래스를 알수 없기 때문인데,  
인터페이스를 이용하기 위해서는 최소한의 클라이언트와의 계약(API)를 유추할 수 있어야 한다.
즉, 리플렉션에서 사용되는 코드의 뼈대정도는 알고 있어야 한다는 뜻이 된다.

또, 인터페이스를 상속한 콘크리트 클래스만의 기능을 사용할수 없다.

성능에 관해서는 아직도 이야기가 많은데,
1. 기본적으로 jvm에 의해서 최적화 될수 없으므로 1차적으로 성능이 나쁘고
2. 시스템에 따라 차이는 있지만 클래스를 lookup 하는데도 비용이 들고
3. (optional) setAccessible() 을 수행하는데도 비용이 든다.

여기서, 1번을 좀 더 자세히 설명하자면   
new 키워드를 이용하는 경우 jvm은 어떤 생성자를 선택해야하는지 컴파일 타임에 알수 있으므로 런타임에 비용이 들지 않지만  
Class.newInstance() 을 이용하는 경우 리플렉션은 호출할 적절한 생성자를 결정해야 하므로(권한이 있는지 까지도) 추가적인 비용이 든다.

성능에 관해서 이야기가 많은 이유는,  
리플렉션 벤치마크 코드 자체도 jvm에서 최적화를 하기 때문에 제대로 된 벤치마크가 매우 어렵고,  
실행 환경에 따라서 결과가 다르고, 자바 버전에 따라 최적화도 많이 이루어졌기 때문.

리플렉션이 강력하긴 하지만 퍼포먼스적으로 문제가 있다는 것은 일반적으로는 사실이기 때문에  
사용한다면 반복문에서는 사용을 자제하고, 사용해야한다면 캐싱을 적극적으로 사용하여 오버헤드를 줄여야 함. 


무조건 이래야 한다 가 아니라 적당히 안전함과 기능을 트레이드오프하는 코드를 작성해야 한다로 이해하자.